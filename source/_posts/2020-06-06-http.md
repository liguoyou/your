---
title: 简单的了解 HTTP 协议
date: 2020-06-06 23:16:20
tags:
  - http
  - 状态码
  - 持久连接
  - keepAlive
categories:
  - [学习笔记, http]
excerpt: HTTP 协议的简单了解：HTTP 协议的主要特点、Keep-Alive、HTTP 报文、http 状态码等...
---

> Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通信的。

## HTTP 协议的主要特点

### 1.简单快速

客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

### 2.灵活

HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type（Content-Type 是 HTTP 包中用来表示内容类型的标识）加以标记

### 3.无连接

无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，**大部分通道实际上会很空闲、无端占用资源。**因此 HTTP 的设计者有意利用这种特点将协议设计为**请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。**

随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，**Keep-Alive** 被提出用来解决这效率低的问题。

Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当 Web 服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。

这样一来，**客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外）**，当客户端发送另外一个请求时，就使用这条已经建立的连接。

### 4.无状态

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。

客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。

### 5.支持客户/服务器模式

## HTTP 报文的组成部分

### 请求报文

- 请求行
- 请求头
- 空行
- 请求体

### 响应报文

- 状态行
- 响应行
- 空行
- 响应体

## HTTP 方法

1. GET 获取资源
2. POST 传输资源
3. PUT 更新资源
4. DELETE 删除资源
5. HEAD 获取报文首部

### POST 和 GET 的区别

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求
- GET 产生的 URL 地址可以被收藏
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式
- GET 请求会被浏览器主动缓存
- GET 请求在 URL 中传送的参数是有长度限制的
- 对参数的数据类型，GET 只接受 ASCLL 字符，而 POST 没有限制
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息
- GET 参数通过 URL 传递，而 POST 放在 Request body 中

## HTTP 状态码

**常见状态码：**

100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。

200~299：表示成功接收请求并已完成整个处理过程。常见 200
200：OK 客户端请求成功
206: Partial Content 客户发送了一个带有 Range 头的 GET 请求，服务器完成了它

300~399：为完成请求，客户需进一步细化请求。
302：请求的资源已经移动一个新地址、
304：客户端有缓存的文档，并发出了一条件性的请求，服务端告诉客户，原来缓存的文档还可以继续使用

400~499：客户端的请求有错误
400：客户端请求有语法错误，不能被服务器所理解
401：请求未经授权，这个状态码必须和 WWW-Authenticate 报头域一起使用
403：对被请求页面的访问被禁止
404：请求资源不存在

500~599：服务器端出现错误
500：服务器发生不可预期的错误，
503：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常

## 什么是持久连接

HTTP 协议采用"请求-应答"模式，当使用普通模式，即非 KeepAlive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接 （无连接的特点）

当使用 KeepAlive 模式，（又称持久连接，连接重用）时，Keep-Alive 功能是客户端到服务端的连接持续有效，当出现对服务器的后继请求时，KeepAlive 功能避免了建立或者重新建立连接

## 什么是管线化

管线化机制须通过永久连接完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持）

在使用持久连接的情况下，某个连接消息的传递类似于

请求 1 -> 响应 1 -> 请求 2 -> 响应 2

管线化：某个连接上的消息变成了类似这样

请求 1 -> 请求 2 -> 请求 3 -> 响应 1 -> 响应 2 -> 响应 3

**那么持久连接和管线化的区别在于：**

- 持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求 1 的响应收到之后，才会发送请求 2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。实现并行发送请求。

- 只有 GET 和 HEAD 要求可以进行管线化，而 POST 则有所限制

- 初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议。

- HTTP1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器 Chrome 和 Firefox 默认并未开启管线化支持。

以上为学习笔记，

**参考**

[慕课网的课程](https://coding.imooc.com/class/115.html)
[深入理解 http 协议的特点 - 博客园](https://www.cnblogs.com/xuxinstyle/p/9813654.html)

**收藏** (待读)

[前端基础篇之 HTTP 协议 - 掘金](https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2)
